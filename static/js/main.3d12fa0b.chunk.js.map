{"version":3,"sources":["components/TransformationControls.js","components/ControlPanel.js","components/ImagePreview.js","transformations/basicTransforms.js","transformations/edgeDetection.js","utils/colorUtils.js","transformations/segmentation.js","ImageTransformApp.js","App.js","index.js"],"names":["TransformationControls","_ref","currentTransform","updateParam","type","params","renderSlider","label","param","min","max","description","arguments","length","undefined","React","createElement","className","value","onChange","e","parseInt","target","ColorSchemeSelector","colorScheme","Fragment","ControlPanel","setCurrentTransform","updateCurrentTransformParam","handleImageUpload","addCurrentTransform","removeTransform","resetImage","activeTransformations","hasImage","transformOptions","accept","map","option","key","onClick","disabled","transform","index","transformOption","find","ImagePreview","originalImage","processedImage","handleSaveImage","canvasRef","processedCanvasRef","ref","style","display","src","alt","applyGrayscale","imageData","data","Uint8ClampedArray","i","avg","ImageData","width","height","clamp","Math","applySobelEdgeDetection","resultData","kernelX","kernelY","y","x","pixelIndex","sumX","sumY","ky","kx","kernelIndex","dataIndex","magnitude","sqrt","applyGaussianBlur","kernel","kernelSum","reduce","sum","val","normalizedKernel","sumR","sumG","sumB","round","hsvToRgb","h","s","v","r","g","b","floor","f","p","q","t","assignColorsToSegments","segmentList","segmentColors","colors","segment","hue","rgb","origColor","brightness","random","ImageTransformApp","setOriginalImage","useState","setProcessedImage","setActiveTransformations","contrastValue","brightnessValue","sharpnessValue","thresholdValue","cannyLow","cannyHigh","segmentTolerance","segmentMinSize","useRef","useEffect","current","applyAllTransformations","canvas","ctx","getContext","drawImage","currentImageData","getImageData","applyTransformation","processedCanvas","putImageData","toDataURL","applyContrast","contrast","factor","applyBrightness","applySharpen","amount","c","applyThreshold","threshold","applyCannyEdgeDetection","lowThreshold","highThreshold","blurredData","sobelData","hasStrongNeighbor","applySegmentation","tolerance","minSize","segmentMap","Array","fill","segmentSizes","stack","currentSegment","floodFill","baseR","baseG","baseB","push","count","pos","pop","cx","cy","directions","nx","ny","neighborIndex","nIndex","nr","ng","nb","pow","segColor","mergeMap","neighbors","Set","j","neighborSegment","add","bestNeighbor","minColorDiff","Infinity","neighborArray","from","colorDiff","uniqueSegments","pixelSegment","color","paramName","prev","file","files","reader","FileReader","onload","event","img","Image","result","readAsDataURL","filter","_","link","document","href","download","body","appendChild","click","removeChild","App","ReactDOM","createRoot","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.3d12fa0b.chunk.js","sourcesContent":["import React from 'react';\n\n/**\n * TransformationControls component that renders the appropriate controls\n * based on the selected transformation type\n * \n * @param {Object} props - Component props\n * @param {Object} props.currentTransform - Current transformation settings\n * @param {Function} props.updateParam - Function to update transformation parameters\n */\nconst TransformationControls = ({ currentTransform, updateParam }) => {\n  const { type, params } = currentTransform;\n  \n  // Renders a slider control with label\n  const renderSlider = (label, param, min, max, description = null) => (\n    <div className=\"mb-4\">\n      <label className=\"block text-gray-700 font-bold mb-2\">\n        {label}: {params[param]}\n      </label>\n      <input\n        type=\"range\"\n        min={min}\n        max={max}\n        value={params[param]}\n        onChange={(e) => updateParam(param, parseInt(e.target.value))}\n        className=\"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer\"\n      />\n      {description && (\n        <p className=\"text-sm text-gray-500 mt-1\">{description}</p>\n      )}\n    </div>\n  );\n\n  // Component for selecting color scheme in segmentation\n  const ColorSchemeSelector = () => (\n    <div className=\"mb-4\">\n      <label className=\"block text-gray-700 font-bold mb-2\">\n        Color Scheme\n      </label>\n      <select\n        value={params.colorScheme}\n        onChange={(e) => updateParam('colorScheme', e.target.value)}\n        className=\"block w-full mt-1 rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50\"\n      >\n        <option value=\"rainbow\">Rainbow</option>\n        <option value=\"pastel\">Pastel</option>\n        <option value=\"grayscale\">Grayscale</option>\n        <option value=\"highContrast\">High Contrast</option>\n        <option value=\"preserveBrightness\">Preserve Brightness</option>\n      </select>\n    </div>\n  );\n\n  // Render different controls based on transformation type\n  switch (type) {\n    case 'contrast':\n      return renderSlider('Contrast', 'contrastValue', 0, 200);\n      \n    case 'brightness':\n      return renderSlider('Brightness', 'brightnessValue', 0, 200, 'Value in %');\n      \n    case 'sharpening':\n      return renderSlider('Sharpness', 'sharpnessValue', 0, 10);\n      \n    case 'threshold':\n      return renderSlider('Threshold', 'thresholdValue', 0, 255);\n      \n    case 'canny':\n      return (\n        <>\n          {renderSlider('Low Threshold', 'cannyLow', 0, 255)}\n          {renderSlider('High Threshold', 'cannyHigh', 0, 255)}\n        </>\n      );\n      \n    case 'segmentation':\n      return (\n        <>\n          {renderSlider(\n            'Color Tolerance', \n            'segmentTolerance', \n            1, \n            50, \n            'Lower values create more segments, higher values merge similar colors'\n          )}\n          {renderSlider(\n            'Minimum Segment Size', \n            'segmentMinSize', \n            10, \n            500, \n            'Smaller segments get merged with neighbors'\n          )}\n          <ColorSchemeSelector />\n        </>\n      );\n      \n    default:\n      return null;\n  }\n};\n\nexport default TransformationControls;","import React from 'react';\nimport TransformationControls from './TransformationControls';\n\n/**\n * ControlPanel component that provides the user interface for\n * uploading images and configuring transformations\n * \n * @param {Object} props - Component props\n * @param {Object} props.currentTransform - Current transformation settings\n * @param {Function} props.setCurrentTransform - Function to update the current transformation\n * @param {Function} props.updateCurrentTransformParam - Function to update transformation parameters\n * @param {Function} props.handleImageUpload - Function to handle image uploads\n * @param {Function} props.addCurrentTransform - Function to add current transform to active stack\n * @param {Function} props.removeTransform - Function to remove a transform from the stack\n * @param {Function} props.resetImage - Function to clear all transformations\n * @param {Array} props.activeTransformations - List of active transformations\n * @param {boolean} props.hasImage - Whether an image is currently loaded\n */\nconst ControlPanel = ({\n  currentTransform,\n  setCurrentTransform,\n  updateCurrentTransformParam,\n  handleImageUpload,\n  addCurrentTransform,\n  removeTransform,\n  resetImage,\n  activeTransformations,\n  hasImage\n}) => {\n  // List of available transformations\n  const transformOptions = [\n    { value: 'contrast', label: 'Contrast' },\n    { value: 'brightness', label: 'Brightness' },\n    { value: 'sharpening', label: 'Sharpening' },\n    { value: 'grayscale', label: 'Grayscale' },\n    { value: 'threshold', label: 'Threshold' },\n    { value: 'edges', label: 'Edge Detection (Sobel)' },\n    { value: 'canny', label: 'Edge Detection (Canny)' },\n    { value: 'segmentation', label: 'Color by Segment' }\n  ];\n\n  return (\n    <div className=\"w-full md:w-1/3 bg-white rounded-lg shadow-lg p-6 mb-6\">\n      {/* Image Upload Section */}\n      <div className=\"mb-4\">\n        <label className=\"block text-gray-700 font-bold mb-2\">\n          Upload an image\n        </label>\n        <input\n          type=\"file\"\n          accept=\"image/*\"\n          onChange={handleImageUpload}\n          className=\"block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100\"\n        />\n      </div>\n      \n      {/* Transformation Selection Section */}\n      <div className=\"my-6 border-t border-gray-200 pt-4\">\n        <h2 className=\"text-xl font-bold mb-4\">Add Transformation</h2>\n        \n        <div className=\"mb-4\">\n          <label className=\"block text-gray-700 font-bold mb-2\">\n            Select transformation\n          </label>\n          <select\n            value={currentTransform.type}\n            onChange={(e) => setCurrentTransform({\n              ...currentTransform,\n              type: e.target.value\n            })}\n            className=\"block w-full mt-1 rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50\"\n          >\n            {transformOptions.map(option => (\n              <option key={option.value} value={option.value}>\n                {option.label}\n              </option>\n            ))}\n          </select>\n        </div>\n        \n        {/* Transformation-specific controls */}\n        <TransformationControls \n          currentTransform={currentTransform}\n          updateParam={updateCurrentTransformParam}\n        />\n        \n        {/* Add Transformation Button */}\n        <button\n          onClick={addCurrentTransform}\n          disabled={!hasImage}\n          className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded-md disabled:bg-gray-300 disabled:cursor-not-allowed w-full\"\n        >\n          Add Transformation\n        </button>\n      </div>\n      \n      {/* Active Transformations Section */}\n      {activeTransformations.length > 0 && (\n        <div className=\"my-6 border-t border-gray-200 pt-4\">\n          <h2 className=\"text-xl font-bold mb-4\">Active Transformations</h2>\n          <ul className=\"space-y-2\">\n            {activeTransformations.map((transform, index) => {\n              // Find the label for this transformation type\n              const transformOption = transformOptions.find(\n                option => option.value === transform.type\n              );\n              const label = transformOption ? transformOption.label : transform.type;\n              \n              return (\n                <li key={index} className=\"bg-gray-100 p-2 rounded flex justify-between items-center\">\n                  <span className=\"font-medium\">{index + 1}. {label}</span>\n                  <button\n                    onClick={() => removeTransform(index)}\n                    className=\"text-red-500 hover:text-red-700\"\n                  >\n                    Remove\n                  </button>\n                </li>\n              );\n            })}\n          </ul>\n          <button\n            onClick={resetImage}\n            className=\"mt-4 px-4 py-2 bg-red-500 text-white rounded-md w-full\"\n          >\n            Reset All Transformations\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ControlPanel;","import React, { useRef, useEffect } from 'react';\n\n/**\n * ImagePreview component for displaying original and processed images\n * \n * @param {Object} props - Component props\n * @param {Image} props.originalImage - The original image object\n * @param {string} props.processedImage - Data URL of the processed image\n * @param {Function} props.handleSaveImage - Function to save the processed image\n * @param {React.RefObject} props.canvasRef - Reference to the original canvas\n * @param {React.RefObject} props.processedCanvasRef - Reference to the processed canvas\n */\nconst ImagePreview = ({ \n  originalImage, \n  processedImage, \n  handleSaveImage, \n  canvasRef, \n  processedCanvasRef \n}) => {\n  \n  return (\n    <div className=\"w-full md:w-2/3\">\n      <div className=\"flex flex-wrap gap-4 justify-center\">\n        {/* Original Image Card */}\n        <div className=\"bg-white rounded-lg shadow-lg p-4 mb-6\">\n          <h2 className=\"text-xl font-bold mb-4\">Original Image</h2>\n          <div className=\"w-full overflow-auto\">\n            {/* Hidden canvas used for image data processing */}\n            <canvas \n              ref={canvasRef} \n              className=\"max-w-full h-auto border border-gray-300\" \n              style={{ display: 'none' }} \n            />\n            \n            {/* Display original image */}\n            {originalImage ? (\n              <img \n                src={originalImage.src} \n                alt=\"Original\" \n                className=\"max-w-full h-auto\" \n              />\n            ) : (\n              <div className=\"flex items-center justify-center border border-gray-300 h-64\">\n                <p className=\"text-gray-500\">No image uploaded yet</p>\n              </div>\n            )}\n          </div>\n        </div>\n        \n        {/* Processed Image Card */}\n        <div className=\"bg-white rounded-lg shadow-lg p-4 mb-6\">\n          <h2 className=\"text-xl font-bold mb-4\">Processed Image</h2>\n          <div className=\"w-full overflow-auto\">\n            {/* Hidden canvas used for processed image data */}\n            <canvas \n              ref={processedCanvasRef} \n              className=\"max-w-full h-auto border border-gray-300\" \n              style={{ display: 'none' }} \n            />\n            \n            {/* Display processed image */}\n            {processedImage ? (\n              <img \n                src={processedImage} \n                alt=\"Processed\" \n                className=\"max-w-full h-auto\" \n              />\n            ) : (\n              <div className=\"flex items-center justify-center border border-gray-300 h-64\">\n                <p className=\"text-gray-500\">No transformations applied yet</p>\n              </div>\n            )}\n          </div>\n          \n          {/* Save Button */}\n          <button\n            onClick={handleSaveImage}\n            disabled={!processedImage}\n            className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded-md disabled:bg-gray-300 disabled:cursor-not-allowed\"\n          >\n            Save Processed Image\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ImagePreview;","/**\n * This file contains basic image transformations like\n * contrast, brightness, sharpening, grayscale, and threshold.\n */\n\n/**\n * Adjusts the contrast of an image\n * \n * @param {ImageData} imageData - The image data to process\n * @param {number} contrast - Contrast value (0-200), where 100 is unchanged\n * @returns {ImageData} The processed image data\n */\nexport const applyContrast = (imageData, contrast) => {\n\tconst data = new Uint8ClampedArray(imageData.data);\n\tconst factor = (259 * (contrast + 255)) / (255 * (259 - contrast));\n\t\n\tfor (let i = 0; i < data.length; i += 4) {\n\t  // Apply contrast adjustment to RGB channels\n\t  data[i] = clamp(factor * (data[i] - 128) + 128);\n\t  data[i + 1] = clamp(factor * (data[i + 1] - 128) + 128);\n\t  data[i + 2] = clamp(factor * (data[i + 2] - 128) + 128);\n\t  // Alpha channel remains unchanged\n\t}\n\t\n\treturn new ImageData(data, imageData.width, imageData.height);\n  };\n  \n  /**\n   * Adjusts the brightness of an image\n   * \n   * @param {ImageData} imageData - The image data to process\n   * @param {number} brightness - Brightness value (0-200), where 100 is unchanged\n   * @returns {ImageData} The processed image data\n   */\n  export const applyBrightness = (imageData, brightness) => {\n\tconst data = new Uint8ClampedArray(imageData.data);\n\tconst factor = brightness / 100;\n\t\n\tfor (let i = 0; i < data.length; i += 4) {\n\t  // Apply brightness adjustment to RGB channels\n\t  data[i] = clamp(data[i] * factor);\n\t  data[i + 1] = clamp(data[i + 1] * factor);\n\t  data[i + 2] = clamp(data[i + 2] * factor);\n\t  // Alpha channel remains unchanged\n\t}\n\t\n\treturn new ImageData(data, imageData.width, imageData.height);\n  };\n  \n  /**\n   * Applies sharpening filter to an image\n   * \n   * @param {ImageData} imageData - The image data to process\n   * @param {number} amount - Sharpening intensity (0-10)\n   * @returns {ImageData} The processed image data\n   */\n  export const applySharpen = (imageData, amount) => {\n\t// If amount is 0, return the original image data\n\tif (amount === 0) return imageData;\n\t\n\tconst data = new Uint8ClampedArray(imageData.data);\n\tconst width = imageData.width;\n\tconst height = imageData.height;\n\tconst factor = amount / 10;\n\t\n\t// Create a new array for the result\n\tconst resultData = new Uint8ClampedArray(data);\n\t\n\t// Sharpen kernel\n\tconst kernel = [\n\t  0, -factor, 0,\n\t  -factor, 1 + 4 * factor, -factor,\n\t  0, -factor, 0\n\t];\n\t\n\t// Apply convolution\n\tfor (let y = 1; y < height - 1; y++) {\n\t  for (let x = 1; x < width - 1; x++) {\n\t\tconst pixelIndex = (y * width + x) * 4;\n\t\t\n\t\t// Process each color channel\n\t\tfor (let c = 0; c < 3; c++) {\n\t\t  let sum = 0;\n\t\t  \n\t\t  // Apply the kernel\n\t\t  for (let ky = -1; ky <= 1; ky++) {\n\t\t\tfor (let kx = -1; kx <= 1; kx++) {\n\t\t\t  const kernelIndex = (ky + 1) * 3 + (kx + 1);\n\t\t\t  const dataIndex = ((y + ky) * width + (x + kx)) * 4 + c;\n\t\t\t  sum += data[dataIndex] * kernel[kernelIndex];\n\t\t\t}\n\t\t  }\n\t\t  \n\t\t  resultData[pixelIndex + c] = clamp(sum);\n\t\t}\n\t  }\n\t}\n\t\n\treturn new ImageData(resultData, width, height);\n  };\n  \n  /**\n   * Converts an image to grayscale\n   * \n   * @param {ImageData} imageData - The image data to process\n   * @returns {ImageData} The processed grayscale image data\n   */\n  export const applyGrayscale = (imageData) => {\n\tconst data = new Uint8ClampedArray(imageData.data);\n\t\n\tfor (let i = 0; i < data.length; i += 4) {\n\t  // Calculate luminance using perceptual factors\n\t  const avg = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;\n\t  \n\t  // Set all RGB channels to the same grayscale value\n\t  data[i] = avg;\n\t  data[i + 1] = avg;\n\t  data[i + 2] = avg;\n\t  // Alpha channel remains unchanged\n\t}\n\t\n\treturn new ImageData(data, imageData.width, imageData.height);\n  };\n  \n  /**\n   * Applies threshold filter to an image\n   * Converts to binary black and white based on threshold\n   * \n   * @param {ImageData} imageData - The image data to process\n   * @param {number} threshold - Threshold value (0-255)\n   * @returns {ImageData} The processed image data\n   */\n  export const applyThreshold = (imageData, threshold) => {\n\t// First convert to grayscale\n\tconst grayscaleData = applyGrayscale(imageData);\n\tconst data = grayscaleData.data;\n\t\n\tfor (let i = 0; i < data.length; i += 4) {\n\t  // Apply threshold: set to black or white\n\t  const value = data[i] < threshold ? 0 : 255;\n\t  data[i] = value;\n\t  data[i + 1] = value;\n\t  data[i + 2] = value;\n\t  // Alpha channel remains unchanged\n\t}\n\t\n\treturn new ImageData(data, imageData.width, imageData.height);\n  };\n  \n  /**\n   * Inverts the colors of an image\n   * \n   * @param {ImageData} imageData - The image data to process\n   * @returns {ImageData} The processed image data with inverted colors\n   */\n  export const applyInvert = (imageData) => {\n\tconst data = new Uint8ClampedArray(imageData.data);\n\t\n\tfor (let i = 0; i < data.length; i += 4) {\n\t  // Invert RGB channels\n\t  data[i] = 255 - data[i];\n\t  data[i + 1] = 255 - data[i + 1];\n\t  data[i + 2] = 255 - data[i + 2];\n\t  // Alpha channel remains unchanged\n\t}\n\t\n\treturn new ImageData(data, imageData.width, imageData.height);\n  };\n  \n  /**\n   * Utility function to clamp a value between 0 and 255\n   * Used to ensure valid color values\n   * \n   * @param {number} value - The value to clamp\n   * @returns {number} The clamped value (0-255)\n   */\n  const clamp = (value) => {\n\treturn Math.min(255, Math.max(0, value));\n  };","import { applyGrayscale } from './basicTransforms';\n\n/**\n * Applies Sobel edge detection algorithm to an image\n * Uses horizontal and vertical gradient kernels to detect edges\n * \n * @param {ImageData} imageData - The image data to process\n * @returns {ImageData} The processed image data with edges highlighted\n */\nexport const applySobelEdgeDetection = (imageData) => {\n  // First convert to grayscale\n  const grayscaleData = applyGrayscale(imageData);\n  const data = grayscaleData.data;\n  const width = imageData.width;\n  const height = imageData.height;\n  \n  // Create a new array for the result\n  const resultData = new Uint8ClampedArray(data.length);\n  \n  // Sobel kernels\n  const kernelX = [\n    -1, 0, 1,\n    -2, 0, 2,\n    -1, 0, 1\n  ];\n  \n  const kernelY = [\n    -1, -2, -1,\n     0,  0,  0,\n     1,  2,  1\n  ];\n  \n  // Apply convolution\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const pixelIndex = (y * width + x) * 4;\n      \n      let sumX = 0;\n      let sumY = 0;\n      \n      // Apply kernel to neighboring pixels\n      for (let ky = -1; ky <= 1; ky++) {\n        for (let kx = -1; kx <= 1; kx++) {\n          const kernelIndex = (ky + 1) * 3 + (kx + 1);\n          const dataIndex = ((y + ky) * width + (x + kx)) * 4;\n          \n          sumX += data[dataIndex] * kernelX[kernelIndex];\n          sumY += data[dataIndex] * kernelY[kernelIndex];\n        }\n      }\n      \n      // Calculate gradient magnitude\n      const magnitude = Math.sqrt(sumX * sumX + sumY * sumY);\n      \n      // Set the result pixel\n      resultData[pixelIndex] = magnitude;\n      resultData[pixelIndex + 1] = magnitude;\n      resultData[pixelIndex + 2] = magnitude;\n      resultData[pixelIndex + 3] = 255; // Full opacity\n    }\n  }\n  \n  // Handle border pixels (leave them as black)\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      // Skip non-border pixels\n      if (x !== 0 && x !== width - 1 && y !== 0 && y !== height - 1) {\n        continue;\n      }\n      \n      const pixelIndex = (y * width + x) * 4;\n      resultData[pixelIndex] = 0;\n      resultData[pixelIndex + 1] = 0;\n      resultData[pixelIndex + 2] = 0;\n      resultData[pixelIndex + 3] = 255;\n    }\n  }\n  \n  return new ImageData(resultData, width, height);\n};\n\n/**\n * Applies Canny edge detection algorithm to an image\n * More advanced edge detection with multi-stage processing\n * \n * @param {ImageData} imageData - The image data to process\n * @param {number} lowThreshold - Lower threshold for edge detection\n * @param {number} highThreshold - Higher threshold for edge detection\n * @returns {ImageData} The processed image data with edges highlighted\n */\nexport const applyCannyEdgeDetection = (imageData, lowThreshold, highThreshold) => {\n  // Step 1: Apply Gaussian blur (simplified - using a negative sharpening as blur)\n  const blurredData = applyGaussianBlur(imageData);\n  \n  // Step 2: Apply Sobel operators\n  const sobelData = applySobelEdgeDetection(blurredData);\n  \n  // Step 3: Non-maximum suppression and edge tracking\n  const width = imageData.width;\n  const height = imageData.height;\n  const data = sobelData.data;\n  const resultData = new Uint8ClampedArray(data.length);\n  \n  // Apply double threshold\n  for (let i = 0; i < data.length; i += 4) {\n    const magnitude = data[i];\n    \n    if (magnitude > highThreshold) {\n      // Strong edge\n      resultData[i] = 255;\n      resultData[i + 1] = 255;\n      resultData[i + 2] = 255;\n    } else if (magnitude > lowThreshold) {\n      // Weak edge\n      resultData[i] = 128;\n      resultData[i + 1] = 128;\n      resultData[i + 2] = 128;\n    } else {\n      // Not an edge\n      resultData[i] = 0;\n      resultData[i + 1] = 0;\n      resultData[i + 2] = 0;\n    }\n    \n    resultData[i + 3] = 255; // Full opacity\n  }\n  \n  // Apply hysteresis (connecting weak edges to strong ones)\n  for (let y = 1; y < height - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      const pixelIndex = (y * width + x) * 4;\n      \n      // Only process weak edges\n      if (resultData[pixelIndex] === 128) {\n        let hasStrongNeighbor = false;\n        \n        // Check 8-connected neighborhood\n        for (let ky = -1; ky <= 1; ky++) {\n          for (let kx = -1; kx <= 1; kx++) {\n            if (ky === 0 && kx === 0) continue; // Skip center pixel\n            \n            const neighborIndex = ((y + ky) * width + (x + kx)) * 4;\n            if (resultData[neighborIndex] === 255) {\n              hasStrongNeighbor = true;\n              break;\n            }\n          }\n          if (hasStrongNeighbor) break;\n        }\n        \n        // If connected to a strong edge, make this a strong edge\n        // Otherwise, remove this weak edge\n        if (hasStrongNeighbor) {\n          resultData[pixelIndex] = 255;\n          resultData[pixelIndex + 1] = 255;\n          resultData[pixelIndex + 2] = 255;\n        } else {\n          resultData[pixelIndex] = 0;\n          resultData[pixelIndex + 1] = 0;\n          resultData[pixelIndex + 2] = 0;\n        }\n      }\n    }\n  }\n  \n  return new ImageData(resultData, width, height);\n};\n\n/**\n * Applies a simple Gaussian blur to an image\n * Used as a preprocessing step for Canny edge detection\n * \n * @param {ImageData} imageData - The image data to process\n * @returns {ImageData} The blurred image data\n */\nconst applyGaussianBlur = (imageData) => {\n  const data = new Uint8ClampedArray(imageData.data);\n  const width = imageData.width;\n  const height = imageData.height;\n  const resultData = new Uint8ClampedArray(data);\n  \n  // Gaussian kernel (5x5)\n  const kernel = [\n    2, 4, 5, 4, 2,\n    4, 9, 12, 9, 4,\n    5, 12, 15, 12, 5,\n    4, 9, 12, 9, 4,\n    2, 4, 5, 4, 2\n  ];\n  \n  // Normalize the kernel\n  const kernelSum = kernel.reduce((sum, val) => sum + val, 0);\n  const normalizedKernel = kernel.map(val => val / kernelSum);\n  \n  // Apply convolution with Gaussian kernel\n  for (let y = 2; y < height - 2; y++) {\n    for (let x = 2; x < width - 2; x++) {\n      const pixelIndex = (y * width + x) * 4;\n      \n      let sumR = 0;\n      let sumG = 0;\n      let sumB = 0;\n      \n      // Apply kernel to neighborhood\n      for (let ky = -2; ky <= 2; ky++) {\n        for (let kx = -2; kx <= 2; kx++) {\n          const kernelIndex = (ky + 2) * 5 + (kx + 2);\n          const dataIndex = ((y + ky) * width + (x + kx)) * 4;\n          \n          sumR += data[dataIndex] * normalizedKernel[kernelIndex];\n          sumG += data[dataIndex + 1] * normalizedKernel[kernelIndex];\n          sumB += data[dataIndex + 2] * normalizedKernel[kernelIndex];\n        }\n      }\n      \n      // Set the blurred pixel\n      resultData[pixelIndex] = Math.round(sumR);\n      resultData[pixelIndex + 1] = Math.round(sumG);\n      resultData[pixelIndex + 2] = Math.round(sumB);\n    }\n  }\n  \n  return new ImageData(resultData, width, height);\n};\n\n/**\n * Calculates the gradient direction at each pixel\n * Used for non-maximum suppression in Canny edge detection\n * \n * @param {number} gx - Gradient in x direction\n * @param {number} gy - Gradient in y direction\n * @returns {number} Direction quantized to one of 4 directions (0, 45, 90, 135 degrees)\n */\nconst getGradientDirection = (gx, gy) => {\n  const angle = Math.atan2(gy, gx) * (180 / Math.PI);\n  \n  // Convert angle to positive\n  const positiveAngle = (angle + 180) % 180;\n  \n  // Quantize to 4 directions (horizontal, vertical, +45, -45)\n  if ((positiveAngle >= 0 && positiveAngle < 22.5) || (positiveAngle >= 157.5 && positiveAngle < 180)) {\n    return 0; // horizontal\n  } else if (positiveAngle >= 22.5 && positiveAngle < 67.5) {\n    return 45; // +45 degrees\n  } else if (positiveAngle >= 67.5 && positiveAngle < 112.5) {\n    return 90; // vertical\n  } else {\n    return 135; // -45 degrees\n  }\n};","/**\n * Utility functions for color manipulation and conversion\n */\n\n/**\n * Converts HSV (Hue, Saturation, Value) color to RGB (Red, Green, Blue)\n * \n * @param {number} h - Hue value (0-360)\n * @param {number} s - Saturation value (0-1)\n * @param {number} v - Value/Brightness (0-1)\n * @returns {Array} RGB values as [r, g, b] with each component in range 0-255\n */\nexport const hsvToRgb = (h, s, v) => {\n\tlet r, g, b;\n\t\n\t// Make sure h is within 0-360\n\th = ((h % 360) + 360) % 360;\n\t\n\t// Handle special case of s=0 (grayscale)\n\tif (s === 0) {\n\t  r = g = b = v;\n\t  return [\n\t\tMath.round(r * 255),\n\t\tMath.round(g * 255),\n\t\tMath.round(b * 255)\n\t  ];\n\t}\n\t\n\tconst i = Math.floor(h / 60) % 6;\n\tconst f = h / 60 - Math.floor(h / 60);\n\tconst p = v * (1 - s);\n\tconst q = v * (1 - f * s);\n\tconst t = v * (1 - (1 - f) * s);\n\t\n\tswitch (i) {\n\t  case 0:\n\t\tr = v;\n\t\tg = t;\n\t\tb = p;\n\t\tbreak;\n\t  case 1:\n\t\tr = q;\n\t\tg = v;\n\t\tb = p;\n\t\tbreak;\n\t  case 2:\n\t\tr = p;\n\t\tg = v;\n\t\tb = t;\n\t\tbreak;\n\t  case 3:\n\t\tr = p;\n\t\tg = q;\n\t\tb = v;\n\t\tbreak;\n\t  case 4:\n\t\tr = t;\n\t\tg = p;\n\t\tb = v;\n\t\tbreak;\n\t  case 5:\n\t\tr = v;\n\t\tg = p;\n\t\tb = q;\n\t\tbreak;\n\t  default:\n\t\tr = v;\n\t\tg = p;\n\t\tb = q;\n\t\tbreak;\n\t}\n\t\n\treturn [\n\t  Math.round(r * 255),\n\t  Math.round(g * 255),\n\t  Math.round(b * 255)\n\t];\n  };\n  \n  /**\n   * Converts RGB color to HSV\n   * \n   * @param {number} r - Red component (0-255)\n   * @param {number} g - Green component (0-255)\n   * @param {number} b - Blue component (0-255)\n   * @returns {Array} HSV values as [h, s, v] where h is 0-360, s and v are 0-1\n   */\n  export const rgbToHsv = (r, g, b) => {\n\t// Normalize RGB values to 0-1 range\n\tr /= 255;\n\tg /= 255;\n\tb /= 255;\n\t\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tconst delta = max - min;\n\t\n\tlet h, s, v;\n\t\n\t// Calculate hue\n\tif (delta === 0) {\n\t  h = 0; // No color, just grayscale\n\t} else if (max === r) {\n\t  h = ((g - b) / delta) % 6;\n\t} else if (max === g) {\n\t  h = (b - r) / delta + 2;\n\t} else {\n\t  h = (r - g) / delta + 4;\n\t}\n\t\n\th = Math.round(h * 60);\n\tif (h < 0) h += 360;\n\t\n\t// Calculate saturation\n\ts = max === 0 ? 0 : delta / max;\n\t\n\t// Value is the max\n\tv = max;\n\t\n\treturn [h, s, v];\n  };\n  \n  /**\n   * Calculates the luminance (perceived brightness) of an RGB color\n   * Uses the formula from WCAG 2.0\n   * \n   * @param {number} r - Red component (0-255)\n   * @param {number} g - Green component (0-255)\n   * @param {number} b - Blue component (0-255)\n   * @returns {number} Luminance value (0-1)\n   */\n  export const getLuminance = (r, g, b) => {\n\t// Convert RGB to relative luminance using coefficients that match human perception\n\treturn (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n  };\n  \n  /**\n   * Calculates color distance between two RGB colors using Euclidean distance\n   * \n   * @param {number} r1 - Red component of first color (0-255)\n   * @param {number} g1 - Green component of first color (0-255)\n   * @param {number} b1 - Blue component of first color (0-255)\n   * @param {number} r2 - Red component of second color (0-255)\n   * @param {number} g2 - Green component of second color (0-255)\n   * @param {number} b2 - Blue component of second color (0-255)\n   * @returns {number} Euclidean distance between the colors in RGB space\n   */\n  export const getColorDistance = (r1, g1, b1, r2, g2, b2) => {\n\treturn Math.sqrt(\n\t  Math.pow(r2 - r1, 2) +\n\t  Math.pow(g2 - g1, 2) +\n\t  Math.pow(b2 - b1, 2)\n\t);\n  };\n  \n  /**\n   * Generates an array of distinct colors using the golden ratio\n   * This ensures colors are spread evenly around the color wheel\n   * \n   * @param {number} count - Number of colors to generate\n   * @param {number} saturation - Saturation value (0-1), default 0.8\n   * @param {number} value - Brightness value (0-1), default 0.9\n   * @returns {Array} Array of RGB colors as [r, g, b] arrays\n   */\n  export const generateDistinctColors = (count, saturation = 0.8, value = 0.9) => {\n\tconst colors = [];\n\tconst goldenRatioConjugate = 0.618033988749895;\n\tlet h = Math.random(); // Start with random hue\n\t\n\tfor (let i = 0; i < count; i++) {\n\t  h += goldenRatioConjugate;\n\t  h %= 1; // Keep h in the range [0, 1)\n\t  \n\t  // Convert to HSV and then to RGB\n\t  const rgb = hsvToRgb(h * 360, saturation, value);\n\t  colors.push(rgb);\n\t}\n\t\n\treturn colors;\n  };\n  \n  /**\n   * Creates a color that preserves the relative luminance of the original\n   * but changes the hue and saturation\n   * \n   * @param {number} r - Red component (0-255)\n   * @param {number} g - Green component (0-255)\n   * @param {number} b - Blue component (0-255)\n   * @param {number} targetHue - Desired hue (0-360)\n   * @param {number} targetSaturation - Desired saturation (0-1)\n   * @returns {Array} RGB values as [r, g, b] with each component in range 0-255\n   */\n  export const preserveLuminance = (r, g, b, targetHue, targetSaturation) => {\n\t// Get current luminance\n\tconst luminance = getLuminance(r, g, b);\n\t\n\t// Convert to HSV\n\tconst [currentHue, currentSat, currentVal] = rgbToHsv(r, g, b);\n\t\n\t// Try different values to match luminance\n\tlet bestDiff = Infinity;\n\tlet bestRgb = [0, 0, 0];\n\t\n\t// Test different values from 0.1 to 1.0\n\tfor (let testValue = 0.1; testValue <= 1.0; testValue += 0.05) {\n\t  const testRgb = hsvToRgb(targetHue, targetSaturation, testValue);\n\t  const testLum = getLuminance(testRgb[0], testRgb[1], testRgb[2]);\n\t  \n\t  const diff = Math.abs(testLum - luminance);\n\t  if (diff < bestDiff) {\n\t\tbestDiff = diff;\n\t\tbestRgb = testRgb;\n\t  }\n\t}\n\t\n\treturn bestRgb;\n  };","import { hsvToRgb } from '../utils/colorUtils';\n\n/**\n * Performs color-based image segmentation\n * Identifies regions of similar color and applies distinct colors to each segment\n * \n * @param {ImageData} imageData - The image data to process\n * @param {number} tolerance - Color similarity tolerance (1-50)\n * @param {number} minSize - Minimum segment size in pixels\n * @param {string} colorScheme - Coloring method to use for segments\n * @returns {ImageData} The processed image data with colored segments\n */\nexport const applySegmentation = (imageData, tolerance, minSize, colorScheme) => {\n  const width = imageData.width;\n  const height = imageData.height;\n  const data = new Uint8ClampedArray(imageData.data);\n  const resultData = new Uint8ClampedArray(data);\n  \n  // Create a map to track which segment each pixel belongs to\n  const segmentMap = new Array(width * height).fill(-1);\n  \n  // A map to track segment size\n  const segmentSizes = {};\n  \n  // A map to track segment average color\n  const segmentColors = {};\n  \n  // Stack for flood fill algorithm\n  const stack = [];\n  \n  // Current segment ID\n  let currentSegment = 0;\n  \n  // Flood fill function\n  const floodFill = (x, y, baseR, baseG, baseB) => {\n    stack.push([x, y]);\n    segmentMap[y * width + x] = currentSegment;\n    \n    // Initialize segment color and size tracking\n    segmentSizes[currentSegment] = 1;\n    segmentColors[currentSegment] = {\n      r: baseR,\n      g: baseG,\n      b: baseB,\n      count: 1\n    };\n    \n    while (stack.length > 0) {\n      const pos = stack.pop();\n      const cx = pos[0];\n      const cy = pos[1];\n      const pixelIndex = (cy * width + cx) * 4;\n      \n      // Check neighboring pixels (4-connected)\n      const directions = [\n        [-1, 0], [1, 0], [0, -1], [0, 1]\n      ];\n      \n      for (let i = 0; i < directions.length; i++) {\n        const nx = cx + directions[i][0];\n        const ny = cy + directions[i][1];\n        \n        // Skip if out of bounds\n        if (nx < 0 || nx >= width || ny < 0 || ny >= height) {\n          continue;\n        }\n        \n        // Skip if already assigned to a segment\n        const neighborIndex = ny * width + nx;\n        if (segmentMap[neighborIndex] !== -1) {\n          continue;\n        }\n        \n        // Get neighbor color\n        const nIndex = neighborIndex * 4;\n        const nr = data[nIndex];\n        const ng = data[nIndex + 1];\n        const nb = data[nIndex + 2];\n        \n        // Calculate color difference\n        const colorDiff = Math.sqrt(\n          Math.pow(baseR - nr, 2) +\n          Math.pow(baseG - ng, 2) +\n          Math.pow(baseB - nb, 2)\n        );\n        \n        // If color is similar enough, add to segment\n        if (colorDiff <= tolerance) {\n          stack.push([nx, ny]);\n          segmentMap[neighborIndex] = currentSegment;\n          segmentSizes[currentSegment]++;\n          \n          // Update average color\n          segmentColors[currentSegment].r += nr;\n          segmentColors[currentSegment].g += ng;\n          segmentColors[currentSegment].b += nb;\n          segmentColors[currentSegment].count++;\n        }\n      }\n    }\n    \n    // Calculate average color for segment\n    const segColor = segmentColors[currentSegment];\n    segColor.r = Math.round(segColor.r / segColor.count);\n    segColor.g = Math.round(segColor.g / segColor.count);\n    segColor.b = Math.round(segColor.b / segColor.count);\n    \n    // Move to next segment\n    currentSegment++;\n  };\n  \n  // Process all pixels\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const index = y * width + x;\n      \n      // Skip if already assigned to a segment\n      if (segmentMap[index] !== -1) {\n        continue;\n      }\n      \n      // Get pixel color\n      const pixelIndex = index * 4;\n      const r = data[pixelIndex];\n      const g = data[pixelIndex + 1];\n      const b = data[pixelIndex + 2];\n      \n      // Start a new segment\n      floodFill(x, y, r, g, b);\n    }\n  }\n  \n  // Merge small segments with neighbors\n  const mergeMap = {};\n  for (let i = 0; i < currentSegment; i++) {\n    mergeMap[i] = i; // Initially, each segment points to itself\n  }\n  \n  // Find small segments and merge them\n  for (let i = 0; i < currentSegment; i++) {\n    if (segmentSizes[i] < minSize) {\n      // Find neighbors of this segment\n      const neighbors = new Set();\n      \n      // Look for neighbors in the segment map\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const index = y * width + x;\n          \n          if (segmentMap[index] === i) {\n            // Check neighboring pixels\n            const directions = [\n              [-1, 0], [1, 0], [0, -1], [0, 1]\n            ];\n            \n            for (let j = 0; j < directions.length; j++) {\n              const nx = x + directions[j][0];\n              const ny = y + directions[j][1];\n              \n              // Skip if out of bounds\n              if (nx < 0 || nx >= width || ny < 0 || ny >= height) {\n                continue;\n              }\n              \n              const neighborSegment = segmentMap[ny * width + nx];\n              if (neighborSegment !== i && neighborSegment !== -1) {\n                neighbors.add(mergeMap[neighborSegment]);\n              }\n            }\n          }\n        }\n      }\n      \n      // Find closest neighbor by color\n      let bestNeighbor = -1;\n      let minColorDiff = Infinity;\n      \n      const neighborArray = Array.from(neighbors);\n      for (let j = 0; j < neighborArray.length; j++) {\n        const neighborSegment = neighborArray[j];\n        const colorDiff = Math.sqrt(\n          Math.pow(segmentColors[i].r - segmentColors[neighborSegment].r, 2) +\n          Math.pow(segmentColors[i].g - segmentColors[neighborSegment].g, 2) +\n          Math.pow(segmentColors[i].b - segmentColors[neighborSegment].b, 2)\n        );\n        \n        if (colorDiff < minColorDiff) {\n          minColorDiff = colorDiff;\n          bestNeighbor = neighborSegment;\n        }\n      }\n      \n      // Merge with best neighbor if found\n      if (bestNeighbor !== -1) {\n        mergeMap[i] = bestNeighbor;\n      }\n    }\n  }\n  \n  // Apply merge mapping (flatten merge chains)\n  for (let i = 0; i < currentSegment; i++) {\n    let target = i;\n    while (mergeMap[target] !== target) {\n      target = mergeMap[target];\n    }\n    mergeMap[i] = target;\n  }\n  \n  // Collect unique segments after merging\n  const uniqueSegments = new Set();\n  for (let i = 0; i < currentSegment; i++) {\n    uniqueSegments.add(mergeMap[i]);\n  }\n  const segmentList = Array.from(uniqueSegments);\n  \n  // Generate distinct colors for each segment\n  const colors = assignColorsToSegments(segmentList, segmentColors, colorScheme);\n  \n  // Apply colors to the result image\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const index = y * width + x;\n      const pixelSegment = segmentMap[index];\n      \n      if (pixelSegment !== -1) {\n        const mergedSegment = mergeMap[pixelSegment];\n        const color = colors[mergedSegment];\n        \n        if (color) {\n          const pixelIndex = index * 4;\n          resultData[pixelIndex] = color.r;\n          resultData[pixelIndex + 1] = color.g;\n          resultData[pixelIndex + 2] = color.b;\n        }\n      }\n    }\n  }\n  \n  return new ImageData(resultData, width, height);\n};\n\n/**\n * Assigns colors to segments based on the specified color scheme\n * \n * @param {Array} segmentList - List of segment IDs\n * @param {Object} segmentColors - Map of segment colors\n * @param {string} colorScheme - Color scheme to use\n * @returns {Object} Map of segment IDs to color objects\n */\nconst assignColorsToSegments = (segmentList, segmentColors, colorScheme) => {\n  const colors = {};\n  \n  switch (colorScheme) {\n    case 'rainbow':\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const hue = (i / segmentList.length) * 360;\n        const rgb = hsvToRgb(hue, 0.8, 0.9);\n        colors[segment] = { r: rgb[0], g: rgb[1], b: rgb[2] };\n      }\n      break;\n      \n    case 'pastel':\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const hue = (i / segmentList.length) * 360;\n        const rgb = hsvToRgb(hue, 0.4, 0.95);\n        colors[segment] = { r: rgb[0], g: rgb[1], b: rgb[2] };\n      }\n      break;\n      \n    case 'grayscale':\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const value = 255 - Math.round((i / segmentList.length) * 220);\n        colors[segment] = { r: value, g: value, b: value };\n      }\n      break;\n      \n    case 'highContrast':\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const hue = (i * 137.5) % 360; // Golden angle to maximize contrast\n        const rgb = hsvToRgb(hue, 1, 1);\n        colors[segment] = { r: rgb[0], g: rgb[1], b: rgb[2] };\n      }\n      break;\n      \n    case 'preserveBrightness':\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const origColor = segmentColors[segment];\n        // Calculate brightness\n        const brightness = (origColor.r * 0.299 + origColor.g * 0.587 + origColor.b * 0.114) / 255;\n        \n        // Generate a random hue but preserve brightness\n        const hue = Math.random() * 360;\n        const rgb = hsvToRgb(hue, 0.8, brightness);\n        colors[segment] = { r: rgb[0], g: rgb[1], b: rgb[2] };\n      }\n      break;\n      \n    default:\n      // Default to rainbow\n      for (let i = 0; i < segmentList.length; i++) {\n        const segment = segmentList[i];\n        const hue = (i / segmentList.length) * 360;\n        const rgb = hsvToRgb(hue, 0.8, 0.9);\n        colors[segment] = { r: rgb[0], g: rgb[1], b: rgb[2] };\n      }\n  }\n  \n  return colors;\n};","import React, { useState, useRef, useEffect } from 'react';\nimport ControlPanel from './components/ControlPanel';\nimport ImagePreview from './components/ImagePreview';\n\n// Import transformation functions\nimport { \n  applyContrast, \n  applyBrightness, \n  applySharpen, \n  applyGrayscale, \n  applyThreshold \n} from './transformations/basicTransforms';\nimport { \n  applySobelEdgeDetection, \n  applyCannyEdgeDetection \n} from './transformations/edgeDetection';\nimport { \n  applySegmentation \n} from './transformations/segmentation';\n\n/**\n * Main component for the Image Transformation App\n * Coordinates transformation operations and manages state\n */\nconst ImageTransformApp = () => {\n  // Image state\n  const [originalImage, setOriginalImage] = useState(null);\n  const [processedImage, setProcessedImage] = useState(null);\n  \n  // Transformation state\n  const [activeTransformations, setActiveTransformations] = useState([]);\n  const [currentTransform, setCurrentTransform] = useState({\n    type: 'contrast',\n    params: {\n      contrastValue: 100,\n      brightnessValue: 100,\n      sharpnessValue: 0,\n      thresholdValue: 128,\n      cannyLow: 50,\n      cannyHigh: 150,\n      segmentTolerance: 20,\n      segmentMinSize: 100,\n      colorScheme: 'rainbow'\n    }\n  });\n  \n  // Canvas references for image processing\n  const canvasRef = useRef(null);\n  const processedCanvasRef = useRef(null);\n  \n  /**\n   * Handles image file uploads\n   */\n  const handleImageUpload = (e) => {\n    const file = e.target.files[0];\n    if (file) {\n      const reader = new FileReader();\n      reader.onload = (event) => {\n        const img = new Image();\n        img.onload = () => {\n          setOriginalImage(img);\n          // Clear any active transformations when uploading a new image\n          setActiveTransformations([]);\n        };\n        img.src = event.target.result;\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  /**\n   * Updates parameters for the current transformation\n   */\n  const updateCurrentTransformParam = (paramName, value) => {\n    setCurrentTransform(prev => ({\n      ...prev,\n      params: {\n        ...prev.params,\n        [paramName]: value\n      }\n    }));\n  };\n\n  /**\n   * Effect to reapply all transformations when active transformations change\n   * or when a new image is loaded\n   */\n  useEffect(() => {\n    if (originalImage && canvasRef.current && processedCanvasRef.current) {\n      applyAllTransformations();\n    }\n  }, [originalImage, activeTransformations]);\n\n  /**\n   * Adds the current transform configuration to the active stack\n   */\n  const addCurrentTransform = () => {\n    setActiveTransformations(prev => [...prev, { ...currentTransform }]);\n  };\n\n  /**\n   * Removes a transformation from the stack by index\n   */\n  const removeTransform = (index) => {\n    setActiveTransformations(prev => prev.filter((_, i) => i !== index));\n  };\n\n  /**\n   * Applies all active transformations in sequence\n   */\n  const applyAllTransformations = () => {\n    // Draw original image on canvas first\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    canvas.width = originalImage.width;\n    canvas.height = originalImage.height;\n    ctx.drawImage(originalImage, 0, 0);\n    \n    // Start with the original image data\n    let currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    \n    // Apply each transformation in sequence\n    for (const transform of activeTransformations) {\n      currentImageData = applyTransformation(currentImageData, transform);\n    }\n    \n    // Display the final result\n    const processedCanvas = processedCanvasRef.current;\n    processedCanvas.width = canvas.width;\n    processedCanvas.height = canvas.height;\n    const processedCtx = processedCanvas.getContext('2d');\n    processedCtx.putImageData(currentImageData, 0, 0);\n    setProcessedImage(processedCanvas.toDataURL('image/png'));\n  };\n\n  /**\n   * Applies a single transformation based on its type and parameters\n   */\n  const applyTransformation = (imageData, transform) => {\n    const { type, params } = transform;\n    \n    switch (type) {\n      case 'contrast':\n        return applyContrast(imageData, params.contrastValue);\n      case 'brightness':\n        return applyBrightness(imageData, params.brightnessValue);\n      case 'sharpening':\n        return applySharpen(imageData, params.sharpnessValue);\n      case 'threshold':\n        return applyThreshold(imageData, params.thresholdValue);\n      case 'grayscale':\n        return applyGrayscale(imageData);\n      case 'edges':\n        return applySobelEdgeDetection(imageData);\n      case 'canny':\n        return applyCannyEdgeDetection(imageData, params.cannyLow, params.cannyHigh);\n      case 'segmentation':\n        return applySegmentation(\n          imageData,\n          params.segmentTolerance,\n          params.segmentMinSize,\n          params.colorScheme\n        );\n      default:\n        return imageData; // Return original if transform type not recognized\n    }\n  };\n\n  /**\n   * Saves the processed image as a file\n   */\n  const handleSaveImage = () => {\n    if (processedImage) {\n      const link = document.createElement('a');\n      link.href = processedImage;\n      link.download = 'processed-image.png';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    }\n  };\n\n  /**\n   * Clears all transformations\n   */\n  const resetImage = () => {\n    if (originalImage) {\n      setActiveTransformations([]);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col min-h-screen bg-gray-100 p-6\">\n      <h1 className=\"text-3xl font-bold text-center mb-8\">Image Transformation App</h1>\n      \n      <div className=\"flex flex-col md:flex-row gap-6\">\n        {/* Left panel - controls */}\n        <ControlPanel \n          currentTransform={currentTransform}\n          setCurrentTransform={setCurrentTransform}\n          updateCurrentTransformParam={updateCurrentTransformParam}\n          handleImageUpload={handleImageUpload}\n          addCurrentTransform={addCurrentTransform}\n          removeTransform={removeTransform}\n          resetImage={resetImage}\n          activeTransformations={activeTransformations}\n          hasImage={!!originalImage}\n        />\n        \n        {/* Right panel - images */}\n        <ImagePreview \n          originalImage={originalImage}\n          processedImage={processedImage}\n          handleSaveImage={handleSaveImage}\n          canvasRef={canvasRef}\n          processedCanvasRef={processedCanvasRef}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default ImageTransformApp;","import React from 'react';\nimport ImageTransformApp from './ImageTransformApp';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ImageTransformApp />\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\n/**\n * Entry point for the React application\n * Creates the root element and renders the App component\n */\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to measure performance in your app, uncomment the following line\n// import { reportWebVitals } from './web-vitals';\n// reportWebVitals(console.log);\n\n// Service worker registration can be added here for offline capabilities\n// For example:\n/*\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js').then(registration => {\n      console.log('SW registered: ', registration);\n    }).catch(registrationError => {\n      console.log('SW registration failed: ', registrationError);\n    });\n  });\n}\n*/"],"sourceRoot":""}